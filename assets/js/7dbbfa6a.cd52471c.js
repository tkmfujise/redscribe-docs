"use strict";(self.webpackChunkredscribe_docs=self.webpackChunkredscribe_docs||[]).push([[7914],{2979:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"writing_dsl","title":"Writing DSL","description":"Basic syntax of Ruby","source":"@site/docs/05.writing_dsl.md","sourceDirName":".","slug":"/writing_dsl","permalink":"/redscribe-docs/docs/writing_dsl","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_label":"Writing DSL"},"sidebar":"tutorialSidebar","previous":{"title":"Example 1: Simple Live Coding App","permalink":"/redscribe-docs/docs/example1_live_coding"},"next":{"title":"Create Ruby files","permalink":"/redscribe-docs/docs/create_ruby_files"}}');var a=s(4848),r=s(8453);const i={sidebar_label:"Writing DSL"},c="Writing DSL",t={},d=[{value:"Basic syntax of Ruby",id:"basic-syntax-of-ruby",level:2},{value:"Hash",id:"hash",level:3},{value:"Method arguments",id:"method-arguments",level:3},{value:"Block",id:"block",level:3},{value:"self",id:"self",level:3},{value:"method_missing",id:"method_missing",level:3},{value:"const_missing",id:"const_missing",level:3},{value:"Object#extend and Module#include",id:"objectextend-and-moduleinclude",level:3},{value:"Module#prepend",id:"moduleprepend",level:3},{value:"Operator Overloading",id:"operator-overloading",level:3},{value:"Basic DSL Example",id:"basic-dsl-example",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"writing-dsl",children:"Writing DSL"})}),"\n",(0,a.jsx)(n.h2,{id:"basic-syntax-of-ruby",children:"Basic syntax of Ruby"}),"\n",(0,a.jsx)(n.p,{children:"Use the REPL to get familiar with Ruby syntax."}),"\n",(0,a.jsx)(n.h3,{id:"hash",children:"Hash"}),"\n",(0,a.jsx)(n.p,{children:"Hash is equivalent to the Dictionary type in GDScript."}),"\n",(0,a.jsx)(n.p,{children:"There are two ways to write a Symbol as a key."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"{ foo: true, bar: false }\n\n{ :foo => true, :bar => false }\n"})}),"\n",(0,a.jsx)(n.p,{children:"The results is the same either way."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> { &"foo": true, &"bar": false }\n'})}),"\n",(0,a.jsx)(n.p,{children:"A Hash can use keys other than Symbols."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"{ 'foo' => true, 1 => 'bar', [:buz] => { 1.0 => 2.0 } }\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> { "foo": true, 1: "bar", [&"buz"]: { 1.0: 2.0 } }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"method-arguments",children:"Method arguments"}),"\n",(0,a.jsxs)(n.p,{children:["In Ruby, keyword arguments can be passed without parentheses ",(0,a.jsx)(n.code,{children:"()"})," or curly braces ",(0,a.jsx)(n.code,{children:"{}"}),".\nAll of the following examples produce the same result."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"Alice says: 'Hello Ruby! \u2764'\n\nAlice(says: 'Hello Ruby! \u2764')\n\nAlice({ says: 'Hello Ruby! \u2764' })\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'[ Alice ] method_missing: [{ &"says": "Hello Ruby! \u2764" }]\n'})}),"\n",(0,a.jsx)(n.p,{children:"When defining a method that accepts an arbitrary number of arguments, you can write it as follows:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["To collect arguments into an Array, use a single asterisk before the parameter name (e.g. ",(0,a.jsx)(n.code,{children:"*args"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:["To collect keyword arguments into a Hash, use two asterisks before the parameter name (e.g. ",(0,a.jsx)(n.code,{children:"**kwargs"}),")"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"def foo(arg, *args, **kwargs)\n  Godot.emit_signal :arg, arg\n  Godot.emit_signal :args, args\n  Godot.emit_signal :kwargs, kwargs\nend\n\nfoo 1, 2, 3, foo: true, :bar => 'buz'\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'[ arg ] signal emitted: 1\n\n[ args ] signal emitted: [2, 3]\n\n[ kwargs ] signal emitted: { &"foo": true, &"bar": "buz" }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"block",children:"Block"}),"\n",(0,a.jsxs)(n.p,{children:["Blocks are a distinctive feature of Ruby. You can pass a block\u2014a special kind of argument\u2014to a method using either curly braces ",(0,a.jsx)(n.code,{children:"{}"})," or the ",(0,a.jsx)(n.code,{children:"do ... end"})," syntax."]}),"\n",(0,a.jsxs)(n.p,{children:["You can evaluate a block passed to a method by using ",(0,a.jsx)(n.code,{children:"yield"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"def hello\n  result = yield\n  \"Hello #{result}\"\nend\n\ndef world!\n  'world!'\nend\n\nhello { world! }\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> "Hello world!"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To receive a Block as a parameter, prefix the variable name with an ampersand, like ",(0,a.jsx)(n.code,{children:"&block"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"@block = nil\ndef run(&block)\n  @block = block\nend\n\nrun { block_called! }\n# or\nrun do\n  block_called!\nend\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> "#<Proc:0x1ee61f63fc0 -:->"\n'})}),"\n",(0,a.jsx)(n.p,{children:"In Ruby, a Block passed to a method becomes a procedural object known as an instance of the Proc class."}),"\n",(0,a.jsx)(n.p,{children:"Blocks are commonly used in DSLs because they offer the following characteristics:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"They are not evaluated at the time of method invocation"}),"\n",(0,a.jsx)(n.li,{children:"They can be stored in variables"}),"\n",(0,a.jsxs)(n.li,{children:["Unlike other languages that require explicit constructs like ",(0,a.jsx)(n.code,{children:"function"})," to define behavior, Ruby allows concise and implicit block syntax."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"To execute a Proc object, use the following pattern:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"@block.call\n# or\n@block.()\n# or\ninstance_exec(&@block)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:"[ block_called! ] method_missing: []\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"instance_exec"})," evaluates a Proc object in the context of the instance on which the method is called\u2014known as the receiver."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"class Foo\r\n  def block_called!\r\n    1\r\n  end\r\nend\r\n\r\nfoo = Foo.new\r\nfoo.instance_exec(&@block)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:"=> 1\n"})}),"\n",(0,a.jsx)(n.h3,{id:"self",children:"self"}),"\n",(0,a.jsxs)(n.p,{children:["In Ruby, when the receiver of a method call is omitted, ",(0,a.jsx)(n.code,{children:"self"})," is used implicitly.\nIt's important to always be aware of what ",(0,a.jsx)(n.code,{children:"self"})," refers to in a given context."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"class Foo\n  def self.whoami\n    self\n  end\n  \n  def whoami\n    self\n  end\nend\n\n[self, Foo.whoami, Foo.new.whoami]\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:"=> [main, Foo, #<Foo:0x1ee25c4fda0>]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To define class methods and class variables, you can use ",(0,a.jsx)(n.code,{children:"class << self"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"class Actor\n  class << self\n    attr_accessor :current\n\n    def greeting\n      \"Hello! I'm #{current.name}\"\n    end\n  end\n\n  attr_accessor :name\n\n  def initialize(name)\n    self.name = name\n  end\nend\n\nActor.current = Actor.new('Alice')\n\nActor.greeting\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> "#<Actor:0x1ab31c75d90 @name="Alice">"\n\n=> "Hello! I\'m Alice"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"method_missing",children:"method_missing"}),"\n",(0,a.jsxs)(n.p,{children:["All values in Ruby are objects, and every object is an instance of a class. Even ",(0,a.jsx)(n.code,{children:"true"}),", ",(0,a.jsx)(n.code,{children:"false"}),", and ",(0,a.jsx)(n.code,{children:"nil"})," belong to specific classes."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"self.class              # => Object\nself.class.ancestors    # => [Object, Kernel, BasicObject]\n\nFoo.class               # => Class\nFoo.class.ancestors     # => [Class, Module, Object, Kernel, BasicObject]\n\nFoo.new.class           # => Foo\nFoo.new.class.ancestors # => [Foo, Object, Kernel, BasicObject]\n\ntrue.class              # => TrueClass\ntrue.class.ancestors    # => [TrueClass, Object, Kernel, BasicObject]\n\nfalse.class             # => FalseClass\nfalse.class.ancestors   # => [FalseClass, Object, Kernel, BasicObject]\n\nnil.class               # => NilClass\nnil.class.ancestors     # => [NilClass, Object, Kernel, BasicObject]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The diagram below shows the parent-child relationships among major Ruby classes. All objects ultimately inherit from ",(0,a.jsx)(n.code,{children:"BasicObject"}),"."]}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TB;\n    BasicObject --\x3e Kernel\r\n    Kernel --\x3e Object\r\n    Object --\x3e Module\r\n    Module --\x3e Class\r\n    Object --\x3e Comparable\r\n    Comparable --\x3e Numeric\r\n    Numeric --\x3e Integer\r\n    Numeric --\x3e Float\n    Comparable --\x3e String\n    Object --\x3e Enumerable\n    Enumerable --\x3e Array\n    Comparable --\x3e Symbol\n    Enumerable --\x3e Hash"}),"\n",(0,a.jsxs)(n.p,{children:["You can use ",(0,a.jsx)(n.code,{children:"methods"})," to retrieve all public and protected methods available to an object."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"1.methods # => [truncate, tap, hash, !, %, upto, ===, <=>, &, +, to_r, ...]\n"})}),"\n",(0,a.jsx)(n.p,{children:"When a method is called on an object and is not defined in its class,\nRuby searches up the class hierarchy to find a metching method."}),"\n",(0,a.jsxs)(n.p,{children:["In the method is not found even after reaching ",(0,a.jsx)(n.code,{children:"BasicObject"}),", Ruby normally raises a ",(0,a.jsx)(n.code,{children:"NoMethodError"}),".\nHowever, in ReDScribe, this exception is intercepted by defining a custom ",(0,a.jsx)(n.code,{children:"method_missing"})," method. Instead of raising an error, it emits a ",(0,a.jsx)(n.code,{children:"method_missing"})," signal."]}),"\n",(0,a.jsxs)(n.p,{children:["While ",(0,a.jsx)(n.code,{children:"method_missing"})," can be risky, it provides powerful metaprogramming capablities."]}),"\n",(0,a.jsx)(n.p,{children:"For example, it can be used like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"module IntegerExt\n  def to_kanji\n    chars = %w(\u3007 \u4e00 \u4e8c \u4e09 \u56db \u4e94 \u516d \u4e03 \u516b \u4e5d)\n    to_s.split('').map{|i| chars[i.to_i] }.join\n  end\n\n  def method_missing(name, *args)\n    \"#{to_kanji}#{name}#{args.map(&:to_s).join}\"\n  end\nend\nInteger.prepend IntegerExt\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"2025.\u5e74 7.\u6708 19.\u65e5\n\n5.\u5146 300.\u5104\u5186\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> "\u4e8c\u3007\u4e8c\u4e94\u5e74\u4e03\u6708\u4e00\u4e5d\u65e5"\r\n\n=> "\u4e94\u5146\u4e09\u3007\u3007\u5104\u5186"\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"method_missing"})," is especially useful when it's difficult or inefficient to predefine many individual methods."]}),"\n",(0,a.jsx)(n.h3,{id:"const_missing",children:"const_missing"}),"\n",(0,a.jsxs)(n.p,{children:["In Ruby, ",(0,a.jsx)(n.code,{children:"method_missing"})," is used when a method can't be found, and ",(0,a.jsx)(n.code,{children:"const_missing"})," is used when a constant is missing."]}),"\n",(0,a.jsxs)(n.p,{children:["Identifiers starting with an uppercase letter (A\u2013Z) and without arguments are interpreted as constants rather than methods. Therefore, to define such names dynamically, you need to use ",(0,a.jsx)(n.code,{children:"const_missing"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"Alice # const_missing\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'def Object.const_missing(name)\n  "#{name} was called"\nend\n\nAlice\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> "Alice was called"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"objectextend-and-moduleinclude",children:"Object#extend and Module#include"}),"\n",(0,a.jsxs)(n.p,{children:["To add methods to an ",(0,a.jsx)(n.code,{children:"Object"}),", use ",(0,a.jsx)(n.code,{children:"extend"}),".\nTo add instance methods to a ",(0,a.jsx)(n.code,{children:"Module"})," or ",(0,a.jsx)(n.code,{children:"Class"}),", use ",(0,a.jsx)(n.code,{children:"include"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"module Hello\n  def hello!\n    self.to_s + ' hello!'\n  end\nend\n\nmodule Yeah\r\n  def yeah!\r\n    self.to_s + ' yeah!'\r\n  end\r\nend\r\n\r\nclass Bar\r\n  extend Hello\n  include Yeah\r\nend\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"Bar.hello!\nBar.yeah!\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> "Bar hello!"\n\n[ yeah! ] method_missing: []\r\n=> <null>\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"Bar.new.hello!\r\nBar.new.yeah!\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'[ hello! ] method_missing: []\n=> <null>\n\n=> "#<Bar:0x1ee25c4c650> yeah!"\r\n'})}),"\n",(0,a.jsx)(n.h3,{id:"moduleprepend",children:"Module#prepend"}),"\n",(0,a.jsxs)(n.p,{children:["To override methods in Ruby's built-in classes, use ",(0,a.jsx)(n.code,{children:"prepend"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Unlike ",(0,a.jsx)(n.code,{children:"include"}),", ",(0,a.jsx)(n.code,{children:"prepend"})," adds the module to the beginning of the inheritance chain, allowing methods to be overridden."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"''.to_i # => 0\n1.to_s  # => '1'\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"module Helper\n  def to_i\n    super + 100\n  end\n\n  def to_s\n    super + '!'\n  end\nend\n\nString.include Helper\nInteger.prepend Helper\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"''.class.ancestors # => [String, Helper, Comperable, ...]\n1.class.ancestors  # => [Helper, Integer, Numeric, ...]\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"''.to_i\n\n1.to_s\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:"=> 0\n\n=> '1!'\n"})}),"\n",(0,a.jsx)(n.h3,{id:"operator-overloading",children:"Operator Overloading"}),"\n",(0,a.jsx)(n.p,{children:"Ruby also supports operator overloading."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:":first > :second           # => false\n:first > :second > :third  # method_missing\n\n- :Ruby                    # method_missing\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'class SymbolChain\n  attr_accessor :chain\n\n  def initialize(origin)\n    self.chain = [origin]\n  end\n\n  def add(sym)\n    tap { self.chain << sym }\n  end\n  alias_method :>, :add\nend\n\nmodule SymbolExt\n  def >(other)\n    SymbolChain.new(self).add(other)\n  end\n\n  def -@\n    "I love #{self}"\n  end\nend\n\nSymbol.prepend SymbolExt\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:":first > :second > :third\n\n- :Ruby\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'=> "#<SymbolChain:0x1ab31c765a0 @chain=[:first, :second, :third]>"\n\n=> "I love Ruby"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"basic-dsl-example",children:"Basic DSL Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"class Player\n  attr_accessor :name\n\r\n  def initialize(name)\r\n    self.name = name\r\n  end\r\n\r\n  def walk\n    emit :walk\r\n  end\r\n\r\n  def jump\r\n    emit :jump\r\n  end\n\n  private\n    def emit(key)\n      Godot.emit_signal key, { name: name }\n    end\r\nend\r\n\n\r\ndef player(name, &block)\r\n  Player.new(name).instance_exec(&block)\r\nend\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"player 'Alice' do\n  3.times { walk }\n  jump\nend\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-txt",metastring:'title="Output"',children:'[ walk ] signal emitted: { &"name": "Alice" }\r\n[ walk ] signal emitted: { &"name": "Alice" }\r\n[ walk ] signal emitted: { &"name": "Alice" }\r\n[ jump ] signal emitted: { &"name": "Alice" }\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);