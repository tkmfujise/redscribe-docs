---
sidebar_label: 'Example 2: 会話ダイアログを作る'
---
import Zoom from 'react-medium-image-zoom';

# Example 2: 会話ダイアログを作る

登場人物による会話シーンを作成します。

## DSL を考える

### シナリオを作成する

登場人物の発言を時系列で簡潔に書けるよう、以下のような DSL にしようと思います。

これがプログラミング言語で書かれているとは思わないかもしれませんが、これが動くのが Ruby の柔軟性です。

```ruby title="scenario.rb"
Narrator;
  says "Alice is resting in the field."
  says "Suddenly, she hears a panicked voice from afar."

scene :riverbank

WhiteRabbit; got :flustered
  says "I'm late, I'm late, I'm late!"

Alice;
  says "Hi! Where are you going?"

WhiteRabbit;
  says "I'm late, I'm late, for a very important date!"

Alice; with :flustered
  says "Wait!"

Narrator;
  says "Alice chased after the rabbit."
  says "But the rabbit disappeared into a burrow."

scene :burrow

Alice;
  says "He went in here."
  asks "Should I go in too?"
  if ___?
    says "Alright, here goes!"
  else
    says "It looks so narrow and grimy... I really shouldn't."
    begin
      says "But I just can't stop wondering."
      asks "Maybe I should go in after all?"
    end until ___?
  end

Narrator;
  says "As Alice entered the burrow, the ground gave away and she fell down."
```

### DSL を実行するためのヘルパーを作成する

上記の DSL  を動かすためのコードを書いてみます。

ちょっといろんなメタプログラミングを使ってしまいましたが、すべては理想の DSL を動かすためです。

```ruby title="helper.rb"
# = Redirects method calls to Xxx.current
#
#   `delegate Foo, :bar` means calling `bar` will forward to `Foo.current.bar`
#
def delegate(const, *keys)
  keys.each do |key|
    define_method(key) do |*args|
      const.current.send(key, *args)
    end
  end
end


class Dialogue
  class << self
    attr_accessor :current
  end

  attr_accessor :fiber, :last_value

  def initialize(&block)
    self.fiber = Fiber.new do
      yield
      Godot.emit_signal :finished, true
    end
    Dialogue.current = self
  end

  def continue(val = nil)
    fiber.resume(val)
  end

  def listen!
    self.last_value = Fiber.yield
  end

  def ___?
    last_value
  end

  def scene(sym)
    Godot.emit_signal :background, sym
  end
end
delegate Dialogue, :continue, :___?, :scene #


class Speaker
  class << self
    attr_accessor :all, :current

    def current=(speaker)
      current.temporary_face = nil if current
      @current = speaker
    end
  end
  self.all = []

  attr_accessor :name, :temporary_face, :permanent_face

  def initialize(name)
    self.name = name
    self.permanent_face = ''
    Speaker.all << self
  end

  def says(str)
    communicate :says, str
  end

  def asks(str, choices = { 'Yes' => true, 'No' => false })
    communicate :asks, str, choices
  end

  def with(face)
    self.permanent_face = ''
    self.temporary_face = face.to_s
  end

  def got(face)
    self.permanent_face = face.to_s
  end

  def face
    temporary_face || permanent_face
  end

  private
    def emit(key, args = {})
      Godot.emit_signal key, { name: name, face: face, **args }
    end

    def communicate(key, str, choices = {})
      emit key, { content: str, choices: choices }
      Dialogue.current.listen!
    end
end
delegate Speaker, :says, :asks, :with, :got #


# = const_missing
#
#   `Alice;` sets `Speaker.current` to the Speaker instance named "Alice"
#
def Object.const_missing(name)
  speaker = Speaker.all.find{|s| s.name == name.to_s }
  if speaker
    Speaker.current = speaker
  else
    super
  end
end


def speakers(names)
  names.each{|name| Speaker.new(name) }
end


Dialogue.new do
  speakers %w(Narrator WhiteRabbit Alice)

  Narrator;
    says "One sunny afternoon"

  scene :park

  Alice; got :smile
    says "Hi! I'm Alice. I'm curious!"

  WhiteRabbit; with :nervous
    says "Hi, I'm late. I'm busy."
end
```

上記を REPL で実行してみましょう。

```txt title="Output"
=> "#<Dialogue:0x21b9908a140 @fiber=#<Fiber:0x21b9908a050 (created)>>"
```

エラーなく Fiber が作成できました。

続けて、以下を実行します。
```ruby
continue
```
```txt title="Output"
[ says ] signal emitted: { &"name": "Narrator", &"face": <null>, &"content": "One sunny afternoon" }
=> <null>
```

`says` をキーにしたシグナルが発行されました。
`name` に対する `content` も正しく設定されています。うまく動いてそうです。

さらに続けて `continue` を3回実行します。
```txt title="Output"
[ background ] signal emitted: park
[ says ] signal emitted: { &"name": "Alice", &"face": &"smile", &"content": "Hi! I\'m Alice. I\'m curious!" }
=> <null>

[ says ] signal emitted: { &"name": "WhiteRabbit", &"face": &"startled", &"content": "Hi, I\'m late. I\'m busy." }
=> <null>

[ finished ] signal emitted: true
=> true
```
`says` と `background` シグナルが発行され、`says` のそれぞれは `name` に対して期待した `content` と `face` が設定されています。

最後は、すべてが終了したことを検知するための `finished` をキーにしたシグナルが発行されたことを確認できました。

では、終了したのに続けて、`continue` を呼ぶとどうなるでしょうか？ 答えはエラーになります。
```txt title="Output"
Error: resuming dead fiber (FiberError)
```

Fiber 自身は終了したかどうかを状態として持っています。
```ruby
Dialogue.current.fiber

Dialogue.current.fiber.alive?
```
```txt title="Output"
=> "#<Fiber:0x21b9908a050 (terminated)>"

=> false
```
Fiber を使う際は、上記を使ってうまくハンドリングするか、今回の例のように `Fiber.new do ... end` の最後にシグナルを発行するようにして、エラーを回避しましょう。


## シーンを作成する

**Conrol** ノードのシーンを作成して、以下のようなツリーになるよう子ノードを追加します。

`RichTextLabel`, `Buttons`, `ButtonTemplate` は固有名でアクセスできるようにします。

```txt title="ノードツリー"
Control
  ├ VBoxContainer
  │   ├ RichTextLabel
  │   └ Buttons (※ Control ノード)
  │     └ Button
  └ ButtonTemplate (※ Button ノード)
```

画面上部に `RichTextLabel`、画面下部に `Buttons` が表示されるようにします。アンカープリセットなどを使ってうまく配置してみてください。
<Zoom>
![シーンを作成する](/img/tutorial/08.create-a-scene.png)
</Zoom>

配置ができたら、`ButtonTemplate` は非表示にします。
<Zoom>
![ノードツリー](/img/tutorial/08.node-tree.png)
</Zoom>


## GDScript をアタッチする。

```gdscript
extends Control

@export var controller : ReDScribe

func _ready() -> void:
	controller.channel.connect(_handle)


func speek(speaker: String, content: String) -> void:
	%RichTextLabel.text = "(%s)\n%s" % [speaker, content]


func _handle(key: StringName, params: Dictionary) -> void:
	match key:
		&'says': speek(params['name'], params['content'])

```


## さらに省略したDSL
```ruby
Narrator;
- "Alice is resting in the field."
- "Suddenly, she hears a panicked voice from afar."

~ :riverbank

WhiteRabbit; got :flustered
- "I'm late, I'm late, I'm late!"
Alice;
- "Hi! Where are you going?"
WhiteRabbit;
- "I'm late, I'm late, for a very important date!"
Alice; with :flustered
- "Wait!"
Narrator;
- "Alice chased after the rabbit."
- "But the rabbit disappeared into a burrow."

~ :burrow

Alice;
- "He went in here."
! "Should I go in too?"
if ___?
  - "Alright, here goes!"
else
  - "It looks so narrow and grimy... I really shouldn't."
  begin
    - "But I just can't stop wondering."
    ! "Maybe I should go in after all?"
  end until ___?
end

Narrator;
- "As Alice entered the burrow, the ground gave way and she fell down."
```
```ruby
module SymbolExt
  def ~@
    scene self
  end
end
Symbol.prepend SymbolExt

module StringExt
  def -@
    says self
  end

  def !@
    asks self
  end
end
String.prepend StringExt
```

